# Теория

Установка свойства
внешнего ключа - все. что необходимо инфраструктуре Entity Framework Core для
обновления отношения между двумя объектами в БД.



Трехслойная архитектура.Между слоями передаются dto ( часто при помощи mappers). Определение протоколов взаимодействия. Паттерн репозиторий и адаптер


Инфраструктура Entity Framework Соге игнорирует отношения. если только они
явно не включаются в запросы. Это означает. что навигационные свойства. такие как
свойство Catego r y. определенное в классе Product, по умолчанию будут оставляться
равными null. 


# Запросы

В инициировании множества запросов из одного объекта IQueryaЫe<T> нет ничего плохого при условии, что именно в этом состояло ваше намерение. Проблема возникает, когда
вы забываете, каким образом ведут себя объекты IQueryaЬle<T>, обращаетесь с ними
как с объектами IEnumeraЫe<T> и непредумышленно делаете запросы, не замечая их.
В высоконагруженном приложении объем ресурсов, впустую растрачиваемых на несущественные запросы, может стать значительным и привести к увеличению затрат в проекте. 


# MVC

Цель паттерна MVC - разделение приложения на три функциональных области, каждая из которых может содержать и логиу и данные. Цель не в том, чтобы устранить логику из модели. Наоборот, цель в том, чтобы гарантировать наличие в модели только логики предназначенной для создания и управления данными

# ViewModel

Правильно использовать строгую типизацию представлений. Используя ViewBag или ViewData, наше представление теряет строгую типизацию.  Лучше всего использовать ViewModel.

Viewmodel – содержит поля, которые нужны для представлений. Это модель определённого View, или сразу для нескольких представлений. Они могут иметь логику для валидации, используя аннотацию данных для проверки моделей. ViewModel помогает реализовать строгую типизацию представления. Может быть нескольких сущностей в нескольких моделей.

# Проектирование модели данных

Модель - это представление реальных объектов, процессов и правил, которые определяют сферу приложения, известную как предметная
область. 

Модель, которую часто называют моделью предметной области, содержит объекты С# (или объекты предметной области), образующие "вселенную" приложения, и методы. позволяющие манипулировать ими. Представления и контроллеры открывают доступ клиентам к предметной области в согласованной манере, и любое корректно разработанное приложение MVC начинается с хорошо спроектированной модели, котора  затем служит центральным узлом при добавлении контроллеров и представлений. 

# Как работают дескрипторы при связывании данных из формы

Для каждого свойства класса модели GuestResponse определены элементы label и input (или элемент select в случае свойства WillAttend). Каждый элемент ассоциирован со свойством модели с применением еще одного атрибута вспомогательной функции дескриптора - asp-for.  Атрибуты вспомогательных функций дескрипторов конфигурируют элементы, чтобы привязать их к объекту модели.

# Запрос

Привязка модели освобождает нас от решения утомительной и подверженной ошибкам задачи по инспектированию НТТР-запроса и извлечению всех требующихся значений данных, но (что самое важное) при желании мы могли бы обрабатывать запрос вручную, поскольку MVC обеспечивает легкий доступ ко всем данным запроса. Ничто не скрыто от разработчика, но есть несколько удобных средств, которые упрощают работу с НТТР и HTML; тем не менее, использовать их вовсе не обязательно. 

# wwwroot

В проектах MVC соглашению статическое содержмое, доставляемое клиентам  в папку wwwroot, папки которой организованы по типу содержимого, так что таблицы стилей CSS находятся в папке wwwroot/css , файлы JavaScript - в папке wwwroot /js

Стандартная конфигурация ASP.NET включает поддержку обслуживания статического содержимого, такого как изображения, таблицы стилей CSS и файлы JavaScript, которая автоматически отображает запросы на папку wwwroot. 

По соглашению пакеты CSS и JavaScгipt от независимых поставщиков устанавливаются в папку wwwroot /lib

---

# Про дублирование кода

Инфраструктура MVC предлагает несколько средтв, помогающих сократить дублирование. 
К таким средтвам относятся:
- компоновки Razor
- частичные представления
- компоненты представлений. 


#  Про паттерн  MVC

Совет. Многих разработчиков, только приступивших к ознакомлению с паттерном MVC, приводит в замешательство идея помещения логики в модель данных из-за их уверенности
в том, что целью паттерна MVC является отделение данных от логики. Это заблуждение:
цель паперна MVC  -  разделение приложения на три функциональных области, каждая
из которых может содержать и логику, и данные. Цель не в том, чтобы устранить логику
из модели. Наоборот, цель в том, чтобы гарантировать наличие в модели только логики,
предназначенной для создания и управления данными модели.

# Службы

Службы ASP.NEТ - это объекты. которые предоставляют функциональность другим частям приложения.

## Dependency Injection

Метод AddScoped регистрирует сервис с областью действия (scoped lifetime), что означает, что для каждого запроса будет создан один экземпляр этого сервиса. Это означает, что если в рамках одного запроса к вашему приложению несколько раз будет запрошен UserService, все эти запросы будут обслужены одним и тем же экземпляром сервиса habr.com, metanit.com.

В этом примере UserService регистрируется как scoped сервис. Это означает, что для каждого запроса к приложению будет создан новый экземпляр UserService. Это полезно, если ваш сервис хранит состояние, которое должно быть изолировано для каждого запроса.

Обратите внимание, что сервисы с областью действия удаляются в конце запроса. Это означает, что если ваш сервис реализует интерфейс IDisposable, его метод Dispose будет вызван автоматически после обработки запроса

Важно помнить, что выбор между AddScoped и AddTransient зависит от конкретного случая использования. Если ваш сервис должен сохранять состояние между запросами в рамках одного HTTP-запроса, используйте AddScoped. Если ваш сервис легковесный и безсостоятельный, то лучше использовать AddTransient

# Модели

Слой ядра: модели домена и способы работы с моделью, бизнес-логика - это все модель приложения
POCO – это обычные классы и объекты C#, находящиеся в памяти. Нет никаких особых требований к наследованию или атрибутов, необходимых для их использования с ASP.NET Core.
Модель привязки – это вся информация, предоставляемая пользователем при выполнении запроса, а также дополнительные контекстные данные. Сюда входят такие вещи, как параметры маршрута, извлеченные из URL-адреса, строка запроса и данные формы или данные в формате JSON в теле запроса.
Модель приложения – модель приложения на самом деле не является моделью ASP.NET Core. Как правило, это больше концепция, целая группа различных сервисов и классов – все, что необходимо для выполнения какого-либо бизнес-действия в вашем приложении. Она может включать в себя модель предметной области (которая представляет то, что ваше приложение пытается описать) и модели базы данных (которые представляют данные, хранящиеся в базе данных), как и любые другие, дополнительные сервисы.





Составь список  своих целей в одном списке, а список людей с которыми вы общаетесь в другом и проведите от каждой цели к человеку, который относиться к вашей цели. Покажите мне своих друзей.


Скачать книги
«React в действии» Марка Тиленса Томаса (Manning, 2018);  «Angular в действии» Джереми Уилкена (Manning, 2018);   «Vue.js в  действии» Эрика Хэнчетта и  Бенджамина Листвона (Manning, 2018);  «Blazer в действии» Криса Сейнти (Manning, 2021)


---
Основная задача тега-хелпера формы – создать атрибут action, но он выполняет одну важную дополнительную функцию: создает скрытое поле для предотвращения межсайтовой подделки запросов.


ModelState.AddModelError( string.Empty, "Cannot convert currency to itself");
Или можно создать атрибут валидации

Ошибки на уровне модели отображаются только с помощью тег-хелпера сводки сообщений валидации. Без него у пользователей не будет никаких указаний на то, что в форме есть ошибки, поэтому они не смогут исправить их

Атрибут asp-append-version загрузит файл, на который указывает ссылка, и сгенерирует уникальный хеш на основе его содержимого. Затем он добавляется в виде уникальной строки запроса к URL-адресу ресурса

<environment include="Testing,Staging">
           <div class="warning">You are currently on a testing environment</div>
  </environment>

каждый раз, когда вы возвращаете статус ошибки, например 404 Not Found, по возможности нужно возвращать сведения о проблеме, которые позволят вызывающему компоненту диагностировать проблему. В ASP.NET Core это рекомендуется делать с помощью класса ProblemDetails.

можно легко вернуться к библиотеке Newtonsoft.Json. Установите пакет Microsoft.AspNetCore.Mvc.NewtonsoftJson в свой проект и обновите метод AddControllers() из файла Startup.cs: services.AddControllers() .AddNewtonsoftJson(); Так вы переключите форматеры ASP.NET Core на использование Newtonsoft. Json вместо System.Text.Json.

Чтобы добавить форматер вывода XML1 , используйте следующий код:
services.AddControllers() .AddXmlSerializerFormatters();

Инверсия управления описывает паттерн, в котором фреймворк вызывает ваш код для обработки запроса, вместо того чтобы вы сами писали код для парсинга запроса из байтов на сетевой карте.


Для .NET доступно множество контейнеров внедрения зависимостей: Autofac, Lamar, Unity, Ninject, Simple Injector...


Программирование на уровне интерфейса – распространенный паттерн проектирования, который помогает еще больше уменьшить связанность системы, поскольку в этом случае вы не привязаны к одной реализации. Это особенно полезно, если вы делаете классы тестируемыми, поскольку можете создавать «фиктивные» реализации своих зависимостей в целях тестирования

принципы, лежащие в основе внедрения зависимостей, кажутся разумными – имея слабосвязанный код, легко полностью изменить или заменить реализации

Процесс сообщения вашему контейнеру внедрения зависимостей «когда вам нужен IEmailSender, используйте EmailSender» называется регистрацией.

Паттерн, где класс вызывает контейнер внедрения зависимостей напрямую, чтобы запросить класс, называется сервис-локатор. По большому счету следует пытаться избегать использования этого паттерна в своем коде; включайте свои зависимости в  качестве аргументов конструктора напрямую, и  пусть контейнер предоставит их вам

Под капотом встроенный контейнер внедрения зависимостей ASP.NET Core использует оптимизированное отражение для создания зависимостей, но разные контейнеры могут использовать другие подходы.

Если нужно запрашивать конкретный конструктор

services.AddSingleton( new EmailServerSettings ( host: "smtp.server.com", port: 25 ));

services.AddScoped( provider => new EmailServerSettings ( host: "smtp.server.com", port: 25 ));

Создание метода расширения для регистрации своего сервиса

public static IServiceCollection AddEmailSender( this IServiceCollection services) { services.AddScoped(); services.AddSingleton(); services.AddScoped(); services.AddSingleton( new EmailServerSettings ( host: "smtp.server.com", port: 25 )); return services; }


Контейнер внедрения зависимостей будет использовать последнюю зарегистрированную реализацию сервиса при разрешении одного экземпляра сервиса


Использование конструктора в качестве единого местоположения, объявляющего все зависимости класса, может быть полезно, поэтому я использую атрибут [FromServices] только в тех редких случаях, когда создание экземпляра зависимости затратно и используется лишь в одном методе действия.

Можно внедрить сервис в шаблон Razor с помощью директивы @inject, указав тип, который нужно будет внедрить, и имя внедряемого сервиса в шаблоне.

экземпляры страницы Razor и контроллера API также являются кратковременными и всегда создаются заново.

Кратковременные жизненные циклы могут привести к  созданию большого количества объектов, поэтому они имеют смысл для легковесных сервисов без состояния.

Scoped
Из-за природы веб-запросов часто можно встретить сервисы, регистрируемые как scoped-зависимости в ASP.NET Core. Контексты базы данных и сервисы аутентификации – распространенные примеры сервисов, которые должны быть ограничены запросом  – все, что вы хотите совместно использовать в своих сервисах в рамках одного запроса, но необходимо изменить между запросами. В целом вы встретите множество сервисов, зарегистрированных с использованием данного жизненного цикла, особенно это касается всего, что использует базу данных или зависит от конкретного запроса.

Singleton
Данный паттерн особенно полезен для объектов, создание которых связано с большими затратами, которые содержат данные для совместного использования в запросах, или объектов, не имеющих состояния. Последние два момента важны – любой сервис, зарегистрированный как синглтон, должен быть потокобезопасным.

Сервисы-одиночки должны быть потокобезопасными в веб-приложении, поскольку обычно они будут использоваться несколькими потоками во время конкурентных запросов.

Синглтоны удобны для объектов, которые необходимо использовать совместно или которые являются неизменяемыми и их затратно создавать. Сервис кеширования должен быть синглтоном, поскольку всем запросам нужно использовать его совместно. Однако он должен быть потокобезопасным. Точно так же можно зарегистрировать объект настроек, загружаемый с удаленного сервера как синглтон, если вы загружаете настройки один раз при запуске и повторно используете их в течение всего жизненного цикла вашего приложения.

Сервис должен использовать только те зависимости, жизненный цикл которых превышает или эквивалентен жизненному циклу сервиса. Сервис, зарегистрированный как синглтон, может безопасно использовать только singleton- зависимости. Сервис, зарегистрированный как scoped, может безопасно использовать scoped- или singleton-зависимости. Кратковременный сервис может использовать зависимости с любым жизненным циклом.

При включении ValidateScopes контейнер внедрения зависимостей выбросит исключение, когда будет создавать сервис с захваченной зависимостью. По умолчанию эта проверка включена только для окружения разработки

Такая проверка влияет на производительность, поэтому по умолчанию она активируется, только когда ваше приложение работает в окружении разработки, но это должно помочь обнаружить большинство проблем такого рода. Можно включить или отключить эту проверку независимо от окружения, задав параметр ValidateScopes при создании HostBuilder в Program.cs

---

httpClient имеет ограничения в виде проблем исчерпания сокетов ( ip + port) и проблему изменения DNS, например, при балансировке

---

dotnet user-secrets set "MapSettings:GoogleMapsApiKey" F5RJT9GFHKR7

---

Рекомендуется использовать поставщика User Secrets только в  окружении разработки, а  не в  промышленном окружении, поэтому в предыдущем фрагменте вы условно добавляете поставщика в ConfigurationBuilder. В промышленном окружении нужно использовать переменные окружения или Azure Key Vault

---

dotnet new install Clean.Architecture.Solution.Template::8.0.0

dotnet new ca-sln -cf React -o YourProjectName
dotnet new ca-sln -cf None -o YourProjectName

dotnet new ca-usecase --name CreateTodoList --feature-name TodoLists --usecase-type command --return-type int
dotnet new ca-usecase -n GetTodos -fn TodoLists -ut query -rt TodosVm


dotnet ef migrations add "SampleMigration" --project src\Infrastructure --startup-project src\Web --output-dir Data\Migrations

---

Взаимодействие с EF Core в приложении, использующееся в качестве примера, происходит на уровне сервисов, который инкапсулирует весь доступ к данным за пределами фреймворка Razor Pages. Это позволяет разделить задачи и сделать сервисы доступными для тестирования.

---

Зачем отображать данные полученные из запроса в EF на новую модель? Можно использовать AutoMapper

public async Task GetRecipeDetail(int id) { return await _context.Recipes .Where(x => x.RecipeId == id) .Select(x => new RecipeDetailViewModel { Id = x.RecipeId, Name = x.Name, Method = x.Method, Ingredients = x.Ingredients .Select(item => new RecipeDetailViewModel.Item { Name = item.Name, Quantity = $"{item.Quantity} {item.Unit}" }) }) .SingleOrDefaultAsync(); }


---
Фильтры

По умолчанию фильтры выполняются от самой широкой области (глобальные) до самого узкой (действие) при выполнении метода *Executing для каждого этапа. Методы *Executed для фильтров выполняются в обратном порядке.

Порядок выполнения для страниц Razor несколько проще, учитывая, что у вас всего две области действия – глобальные фильтры и фильтры, которые применяются к страницам Razor. Для страниц Razor глобальные фильтры сначала выполняют методы *Executing и PageHandlerSelected, а  затем фильтры страниц. Для методов *Executed фильтры работают в обратном порядке.


можно реализовать интерфейс IOrderedFilter. Он состоит из одногоединственного свойства Order: 
public interface IOrderedFilter
 { int Order { get; } }

Вы можете реализовать это свойство в  фильтрах, чтобы задать порядок их выполнения. Конвейер фильтров упорядочивает фильтры на определенном этапе сначала на основе этого значения, от наименьшего до наивысшего, и использует порядок выполнения фильтров по умолчанию для упорядочивания фильтров с одинаковыми значениями порядка выполнения

Глобальные фильтры страниц

services.AddRazorPages() .AddMvcOptions(options => { options.Filters.Add(new LogResourceFilter()); options.Filters.Add(typeof(LogResourceFilter)); options.Filters.Add(); });

Фильтр определенного этапа реализуется с помощью одной из пары интерфейсов – одного синхронного (sync) и одного асинхронного (async): 
 фильтры авторизации – IAuthorizationFilter или IAsyncAuthorizationFilter; 
 фильтры ресурсов – IResourceFilter или IAsyncResourceFilter; 
 фильтры действий – IActionFilter или IAsyncActionFilter; 
 фильтры страниц – IPageFilter или IAsyncPageFilter; 
 фильтры исключений – IExceptionFilter или IAsyncExceptionFilter; 
 фильтры результатов – IResultFilter или IAsyncResultFilter.

В  большинстве случаев фильтры должны использоваться в  крайнем случае. Где это возможно, часто предпочтительнее применять простой закрытый метод в контроллере или поместить функциональность в  предметную область. Обычно следует использовать фильтры для извлечения повторяющегося, связанного с протоколом HTTP или общего сквозного кода из контроллеров.

---

Microsoft.AspNetCore.Identity.UI

---

dotnet new webapp -au Individual -uld.

---

services.AddDefaultIdentity(options => { options.SignIn.RequireConfirmedAccount = true; options.Lockout.AllowedForNewUsers = true; options.Password.RequiredLength = 12; options.Password.RequireNonAlphanumeric = false; options.Password.RequireDigit = false; })

---
В ASP.NET Core правила, определяющие, авторизован ли пользователь, инкапсулированы в политике.

Утверждение – это информация о пользователе, имеющая вид пары «ключ-значение». Политика определяет требования для успешной авторизации. Она может потребовать, чтобы у пользователя было утверждение,

Вы также можете добавить несколько политик на страницу Razor Page или метод действия, многократно применяя атрибут [Authorize], например [Authorize("Policy1"), Authorize("Policy2")]. Чтобы запрос был авторизован, должны быть удовлетворены все политики.

---
1. Надо сразу практиковать технологию в проекте
2. Написать 5 проектов на моем стеке

---

ASP Core - это presentation. Надо думать, чтобы не зависить от фреймворка, возможность тестирования, проверка бизнес-логики


Техники авторизации на сервере: на основе утверждений и на основе ресурсов
Техника авторизации на клиенте: не показывать пользователю дополнительные функции


Надо разобраться с аутентфикацией и авторизацией на основе токенов и cookie, сессий





